# 光照

无光
基础光（环境光）
漫反射
镜面反射


材质


光照贴图
- 镜面反射贴图
- 漫反射贴图

透光物
- 平行光
- 点光源
- 聚光
- 手电筒
- 平滑/软化边缘

多光源
- 定向光
- 点光源
- 合并光源

## 颜色

每个物体都有颜色，我们需要使用数值来表示现实世界中的物体颜色,通过三个值就可以绘制出大量的颜色值。

颜色使用一个向量

```
vec3(1.0f,0.5f,0.31f);
```

拓展：
我们看到的颜色，基本就是它反射的颜色，不被吸收的颜色。我们看到的阳光是所有可见光的集合，它反射了物体颜色的部分，被反射的部分是我们所感知的部分。

颜色的计算值:

```
物体的颜色 * 光的颜色
vec3 light = lightColor * toyColor;
```

两个相乘得到的值就是最终的结果值了。


## 创建光照场景

准备：
- 投光物，使用立体箱子
- 一个物体代表光源

## 步骤

1.我们首先需要一个顶点着色器绘制箱子。和之前的案例一样。
2.需要绘制一个灯或者是立方体，可以和箱子公用一个，可以进行矩阵变换。
3.将光源变为白色， 将物体设置为一种颜色
4.为了不影响等，需要为灯创建一个着色器

上面绘制等的目的就是可以看到灯的位置。

## 基础光照

现实光照很复杂，但是计算能力有限，所以使用简化的模型，对现实进行模拟。现实的光收到许多的影响，有一种交冯氏光照的模型，它包含：

- 环境 ： 世界上通常也有一些光亮，永远给物体一个颜色
- 漫反射 : 在物体不同方向上现实除不同的效果
- 镜面  ：有光泽物体表面上的亮点。

## 环境光

光通常不是来自于一个光源，而是来自于周围许多的光。即使它们可能并不是那么显而易见，光的属性就是可以向狠毒方向进行发散，从而可以到达不是很临近的点，光可以在一个面上反射，对物体产生影响，叫做全局光照。

我们使用一个很小的光，添加到片段最终颜色中，即使场景中没有直接光源也会发出一些光。

环境光很简单，使用光源乘以光照因子，再乘以物体颜色就可以了。

计算公式

```
光颜色 * 环境因子 * 物体颜色 = 最终颜色
void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 result = ambient * objectColor;
    FragColor = vec4(result, 1.0);
}
```

冯氏光照第一部分就算完成了。

## 漫反射

环境光照不可以提供有趣的结果，漫反射可以，漫反射光照使得物体上与光纤方向越接近片段从光源处获得更多亮度。

一个光源，我们需要知道它的光线以什么角度接触到这个片段，如果是垂直，那么就会更加的亮。

如何测光线与片段的角度？

答：使用法向量的东西，两个向量之间的角度容易通过点乘的方式计算出来。
向量中夹角为0，值为1，反之。

点乘是一个标量：计算光线和片段颜色的影响，不同片段对光的朝向不同，被照亮的也会不同。

- 需要垂直顶点的法向量
- 定向的光线   定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。


### 法向量

法向量是一个垂直于顶点表面的向量，但是顶点本身并没有表面，利用周围的点计算出一个顶点的表面，可以使用x乘求出立方体的所有顶点计算法向量。但是
对于简单的，我们使用手动添加的方式。


### 计算漫反射

我们限制 对每个顶点都有一个法向量，但是仍然需要光的位置和片段的位置向量，光的位置是一个静态位置。

```
void main(){
     gl_Position = projection * view * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = aNormal
}
```

计算光源和向量之间的向量，光的向量是：光源位置向量 - 片段位置向量之间的向量差。

```
vec3 norm = normalize(Normal);
vec3 lightDir = normalize(lightPos - FragPos);
```

下一步是进行点乘  计算出光源对当前片段实际的漫反射影响，结果在乘以光的颜色，得到漫反射的分量，向量角度越大，漫反射分量越小。 

我们对norm和lightDir向量进行点乘，计算光源对当前片段实际的漫发射影响，结果乘以光的颜色，也就是漫反射的分量。漫反射的角度越大，分量越少。

```
float diff = max(dot(norm,lightDir),0.0);
vec3 fiffuse = diff * lightColor;
```

最后在乘以最后的颜色

```
vec3 result = (ambient + diffuse) * objectColor;
FragColor = vec4(result, 1.0);
```

## 镜面光照

镜面光照决定于光的方向向量和物体的法向量，但是也取决于观察方向，我们从什么方向看到了反射之后的光。

我们通过根据法向量翻折入射光的方向来计算反射向量。然后我们计算反射向量与观察方向的角度差，它们之间夹角越小，
镜面光的作用就越大。由此产生的效果就是，我们看向在入射光在表面的反射方向时，会看到一点高光。

反射向量  与  观察向量之间的夹角

省流：反射出来的光纤和眼睛之间的夹角

观察向量是我们计算镜面光照时需要的一个额外变量，我们可以使用观察者的世界空间位置和片段的位置来计算它。之后我们计算出镜面光照强度，用它乘以光源的颜色，并将它与环境光照和漫反射光照部分加和。

摄像机的位置就是观察向量的位置。

```
lightingShader.setVec3("viewPos", camera.Position);
```

颜色的强度，那么如何合理的设置光的强度。

```
视线的方向向量
vec3  viewDir = notmalize(viewPos - FragPos);
vec3 reflectDir = reflect(-lightDir,norm);

float specularStrength = 0.5;
```

需要注意的是我们对lightDir向量进行了取反。reflect函数要求第一个向量是从光源指向片段位置的向量，但是lightDir当前正好相反，是从片段指向光源（由先前我们计算lightDir向量时，减法的顺序决定）。为了保证我们得到正确的reflect向量，我们通过对lightDir向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已标准化的norm向量。

计算镜面

```
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
vec3 specular = specularStrength * spec * lightColor;
```

我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度(Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小.

# 投光物

之前部分都是一个点光源，现在需要设置很多类型的光照，每种都不同，将光投射到物体的光源叫做投光物。

## 平行光

每条光线近似于平行的，和光源位置无关，因为光线都是平行的，所以计算光照都会很类似。

定义一个光线的方向向量而不是位置信息类模拟光源