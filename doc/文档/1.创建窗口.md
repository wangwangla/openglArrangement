# 创建窗口

视口：就是告诉opengl渲染的尺寸的大小，opengl才知道使用多大的尺寸来进行绘制。
(shadertoy也是一样，它的iRex哪个就是屏幕大小)
根据窗口大小显示数据和坐标

使用如下函数来设置窗口的维度。

```java
glViewport(0, 0, 800, 600);
```

开始位置  以及屏幕的宽和高   所以显示的大小不需要是显示屏的大小，多余位置可以显示其他内容。

前两个表示位置，后面两个表示宽高。OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。

例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)
，前面这句话是不准确的，它是通过矩阵变换，最终给到opengl也是归一化的。


窗口大小改变的时候，视口也需要被调整，每次窗口调用的时候都会进行调用。

· 也就是每次看到的surfaceChange方法。


## 双缓存区

使用单缓冲区存在闪烁的问题，这是由于从上向下进行的，前缓冲区和后缓冲区，先写入前缓冲区在写完之后在刷新出去。


## 事件处理

等绘制学完了，来补充。

## 我们绘制之前需要一次清屏，清屏的方法

```java
glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
```

glClearColor函数是一个状态设置函数，而glClear函数则是一个状态使用的函数，它使用了当前的状态来获取应该清除为的颜色。

## 补充

深度缓冲区一定需要清除，否则深度值将不会更新，可能显示不出结果。