# 模板测试

每个片端执行了之后就会进入到模板测试中，和深度一样，可能会丢弃片段，通过的部分进行展示，没有通过的就丢弃掉。

保留的进入深度测试。

每个像素点的值都是8为，可以由256中模板值，如果存在某个模板值的时候就会选择丢弃或者是保留。

很简单的例子

1111
1001
1001
1111

22222222222222222
22222222222222222
22222222222222222
22211111222222222
22210012222222222
22210012222222222
22222222222222222

比如上面，模板为1的显示，模板为0的不显示

先将值写入缓冲区中，然后读取模板的值，来决定片段是丢弃还是保留
- 启用模板测试
- 渲染物体，更新缓冲区模板
- 关闭模板测试
- 渲染物体，选择是通过还是不通过

模板缓冲首先会被清为0，然后使用1填充，场景中片段将会旨在片段模板为1的时候被渲染。、

模板缓冲允许我们在模板缓冲设定一个特定值，渲染时修改模板缓冲的内容，然后在读取这些值，来决定丢弃还是保留。


## 启用

```
glEnable(GL_STENCIL_TEST);
```

每次需要清除模板缓冲区

```
GL_STENCIL_BUFFER_BIT
```

和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。

```
glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样           做与运算的  为1原样显示   
glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）
```

## 模板函数

我们通过两个方法对模板缓冲区进行控制（通过/失败）

```
glStencilFunc
glStencilOp
```

### glStencilFunc

glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：
- func：设置模板测试函数(Stencil Test Function)。
 这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。
 可用的选项有:
 - GL_NEVER
 - GL_LESS
 - GL_LEQUAL
 - GL_GREATER
 - GL_GEQUAL
 - GL_EQUAL
 - GL_NOTEQUAL
 - GL_ALWAYS。它们的语义和深度缓冲的函数类似。
ref：设置了模板测试的参考值,模板缓冲的内容将会与这个值进行比较。
mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。

mask 和ref可以理解为设置的模板和它进行运算，得到的最总的值，作为模板测试中的值

比如：
```
glStencilFunc(GL_EQUAL,1,0xff)
```

等于1的通过测试。

### 如何更新缓冲 

glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，我们能够设定每个选项应该采取的行为：

sfail：模板测试失败时采取的行为。
dpfail：模板测试通过，但深度测试失败时采取的行为。
dppass：模板测试和深度测试都通过时采取的行为。

GL_KEEP	保持当前储存的模板值
GL_ZERO	将模板值设置为0
GL_REPLACE	将模板值设置为glStencilFunc函数设置的ref值
GL_INCR	如果模板值小于最大值则将模板值加1
GL_INCR_WRAP	与GL_INCR一样，但如果模板值超过了最大值则归零
GL_DECR	如果模板值大于最小值则将模板值减1
GL_DECR_WRAP	与GL_DECR一样，但如果模板值小于0则将其设置为最大值
GL_INVERT	按位翻转当前的模板缓冲值

默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试
的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模
板缓冲的话，你需要至少对其中一个选项设置不同的值。


缓存区保留与否以及缓存区中的值然后更新。

所以，通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与
行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。


