# 深度测试

深度缓冲(Depth Buffer)来`防止`被阻挡的面渲染到其它面的前面。讨论这些储存在深度缓冲（或z缓冲(z-buffer)）
中的深度值(Depth Value)，以及它们是如何确定一个片段是处于其它片段后方的。

每个片段都存储了信息，深度缓存区是由窗口自己创建的。绝大多数是24深度值来存储的。

如果测试通过就更新，没有通过就丢弃了。

## 执行位置

深度缓存区在片段着色器之后执行，在屏幕空间执行

屏幕空间坐标和viewport密切相关  可以通过gl_FragCoord进访问
这个xy代表了屏幕的坐标
gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值

## 默认关闭 开启

```
glEnable(GL_DEPTH_TEST);
```
当它启用的时候
- 片段通过深度测试   OpenGL会在深度缓冲中储存该片段的z值
- 如果没有通过深度缓冲 会丢弃该片段

还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值：

glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

## 深度测试的比较

GL_ALWAYS	永远通过深度测试
GL_NEVER	永远不通过深度测试
GL_LESS	    在片段深度值小于缓冲的深度值时通过测试
GL_EQUAL	在片段深度值等于缓冲区的深度值时通过测试
GL_LEQUAL	在片段深度值小于等于缓冲区的深度值时通过测试
GL_GREATER	在片段深度值大于缓冲区的深度值时通过测试
GL_NOTEQUAL	在片段深度值不等于缓冲区的深度值时通过测试
GL_GEQUAL	在片段深度值大于等于缓冲区的深度值时通过测试

默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。

比如3d绘制一个地板，地板上放一个椅子，如果设置为一直通过，那么这个椅子就会被地板盖住

## z值的大小

观察空间的z值可能是投影平截头体的近平面(Near)和远平面(Far)之间的任何值。
一般的我们会将他们放到0到1之间。

F = z - near / far - near;


## 一般不适应线性的

在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确
的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的
时候提供非常高的精度，而在z值很远的时候提供更少的精度。

花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同
的精度吗？线性方程并不会考虑这一点。